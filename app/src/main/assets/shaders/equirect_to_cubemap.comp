#version 450

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0) uniform sampler2D inputEquirect;
// Array of 6 images for the cubemap faces
layout (binding = 1, rgba8) uniform writeonly image2D outputFaces[6];

const float PI = 3.14159265359;

// Rotate a vector by the face orientation
vec3 getDirection(int face, vec2 uv) {
    // uv is in range [-1, 1]
    float u = uv.x;
    float v = uv.y;
    vec3 dir;

    // Cubemap face definition (OpenGL convention)
    // 0: +X (Right)
    // 1: -X (Left)
    // 2: +Y (Top)
    // 3: -Y (Bottom)
    // 4: +Z (Front)
    // 5: -Z (Back)

    // Corrected +Y/-Y logic based on feedback:
    // +Y: (u, 1, -v)
    // -Y: (u, -1, v)

    if (face == 0) dir = vec3(1.0, -v, -u);
    else if (face == 1) dir = vec3(-1.0, -v, u);
    else if (face == 2) dir = vec3(u, 1.0, -v); // Corrected
    else if (face == 3) dir = vec3(u, -1.0, v); // Corrected
    else if (face == 4) dir = vec3(u, -v, 1.0);
    else if (face == 5) dir = vec3(-u, -v, -1.0);

    return normalize(dir);
}

vec2 cartesianToSpherical(vec3 dir) {
    float phi = atan(dir.z, dir.x); // Longitude [-PI, PI]
    float theta = acos(dir.y);      // Latitude [0, PI] (0 is North Pole)

    // Map to UV [0, 1]
    float u = (phi + PI) / (2.0 * PI);
    float v = theta / PI;

    return vec2(u, v);
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    int face = int(gl_GlobalInvocationID.z);

    // Assuming output faces are all same size, get dimensions from image 0
    ivec2 size = imageSize(outputFaces[0]);

    if (pos.x >= size.x || pos.y >= size.y) return;

    // Normalized device coordinates [-1, 1]
    vec2 uv = (vec2(pos) / vec2(size)) * 2.0 - 1.0;

    vec3 dir = getDirection(face, uv);
    vec2 sphericalUV = cartesianToSpherical(dir);

    vec4 color = texture(inputEquirect, sphericalUV);

    imageStore(outputFaces[face], pos, color);
}
