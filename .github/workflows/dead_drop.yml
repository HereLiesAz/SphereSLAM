name: "Context Dead Drop (Sterilized)"

on:
  workflow_dispatch:

jobs:
  drop-package:
    runs-on: windows-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate and Upload
        shell: powershell
        run: |
          # --- Configuration ---
          $BackupPrefix = "project_backup"
          $Timestamp    = Get-Date -Format "yyyyMMdd_HHmmss"
          $Root         = Get-Location
          $OutFile      = Join-Path $Root "${BackupPrefix}_full_${Timestamp}.txt"
          
          # --- The Kill List ---
          # These directories are dead to us. Even if Git tracks them.
          $TrashDirs = @(
              "build", "out", "bin", "obj", 
              ".gradle", ".idea", ".vscode", ".git", 
              "node_modules", "captures", ".cxx", 
              "generated"
          )

          # Files to shoot on sight
          $TrashFiles = @(
              "package-lock.json", "yarn.lock", 
              "local.properties", "*.iml", ".DS_Store", "Thumbs.db"
          )

          # --- Helper Functions ---
          function Test-IsBinary($Path) {
              $BinaryExtensions = @(".png", ".jpg", ".jpeg", ".gif", ".ico", ".webp", ".exe", ".dll", ".so", ".dylib", ".zip", ".jar", ".class", ".pdf", ".db", ".sqlite", ".keystore", ".jks", ".ttf", ".woff", ".eot")
              try {
                  if ($BinaryExtensions -contains [System.IO.Path]::GetExtension($Path).ToLower()) { return $true }
                  # Null-byte check for hidden binaries
                  $bytes = Get-Content $Path -Encoding Byte -TotalCount 512 -ErrorAction SilentlyContinue
                  if (!$bytes) { return $false }
                  if ($bytes -contains 0) { return $true }
                  return $false
              } catch { return $true }
          }

          function Test-IsTrash($Path) {
              # Normalize separators
              $rel = $Path.Replace("\", "/")
              
              # Check Directories
              foreach ($dir in $TrashDirs) {
                  # Match "build/" at start, "/build/" in middle, or "/build" at end
                  if ($rel -match "(^|/)$([Regex]::Escape($dir))(/|$)") { return $true }
              }
              
              # Check Files
              $fname = Split-Path $Path -Leaf
              foreach ($tf in $TrashFiles) {
                  if ($fname -like $tf) { return $true }
              }
              
              return $false
          }

          # --- Execution ---
          Write-Host "Scanning territory..." -ForegroundColor Cyan
          
          $RawFiles = @()

          if ((Test-Path ".git") -and (Get-Command "git" -ErrorAction SilentlyContinue)) {
              # Get everything Git knows about (Cached + Others), excluding standard ignores
              $GitOutput = git ls-files -c -o --exclude-standard
              # Convert to full paths
              $RawFiles = $GitOutput | ForEach-Object { Join-Path $Root $_ }
          } else {
              $RawFiles = Get-ChildItem -Recurse -File | Select-Object -ExpandProperty FullName
          }

          # --- Filtration ---
          Write-Host "Purging trash..." -ForegroundColor Yellow
          $CleanList = $RawFiles | Where-Object {
              $relPath = $_.Substring($Root.Path.Length + 1)
              # The active filter:
              if (Test-IsTrash $relPath) { return $false }
              # The backup prefix filter:
              if ($relPath -like "${BackupPrefix}*") { return $false }
              return $true
          }

          # --- Output Generation ---
          Write-Host "Compiling Context..." -ForegroundColor Green
          $Writer = [System.IO.StreamWriter]::new($OutFile)
          
          foreach ($f in $CleanList) {
              $rel = $f.Substring($Root.Path.Length + 1)
              $Writer.WriteLine(">>> $rel")
              
              if (Test-IsBinary $f) {
                  $Writer.WriteLine("[BINARY]")
              } else {
                  try { 
                      $content = [System.IO.File]::ReadAllText($f)
                      $Writer.WriteLine($content) 
                  } catch { 
                      $Writer.WriteLine("[READ ERROR]") 
                  }
              }
              $Writer.WriteLine("`n")
          }
          $Writer.Close()

          # --- Dead Drop ---
          Write-Host "Uploading payload..." -ForegroundColor Cyan
          try {
              $response = Invoke-RestMethod -Uri "https://file.io/?expires=1d" -Method Post -InFile $OutFile
              Write-Host "`nLINK: $($response.link)" -ForegroundColor Green
          } catch {
              Write-Error "Upload failed."
          }
