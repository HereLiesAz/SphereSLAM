name: "Context Dead Drop (Bulletproof)"

on:
  workflow_dispatch:

permissions:
  contents: read

jobs:
  drop-package:
    runs-on: windows-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate and Exfiltrate
        shell: pwsh
        run: |
          # --- Configuration ---
          $BackupPrefix = "project_backup"
          $Timestamp    = Get-Date -Format "yyyyMMdd_HHmmss"
          $Root         = Get-Location
          $OutFile      = Join-Path $Root "${BackupPrefix}_full_${Timestamp}.txt"
          
          # --- The Kill List ---
          $TrashDirs = @("build", "out", "bin", "obj", ".gradle", ".idea", ".vscode", ".git", "node_modules", "captures", ".cxx", "generated")
          $TrashFiles = @("package-lock.json", "yarn.lock", "local.properties", "*.iml", ".DS_Store", "Thumbs.db")

          # --- Helper Functions ---
          function Test-IsBinary($Path) {
              $BinaryExtensions = @(".png", ".jpg", ".jpeg", ".gif", ".ico", ".webp", ".exe", ".dll", ".so", ".dylib", ".zip", ".jar", ".class", ".pdf", ".db", ".sqlite", ".keystore", ".jks", ".ttf", ".woff", ".eot")
              try {
                  if ($BinaryExtensions -contains [System.IO.Path]::GetExtension($Path).ToLower()) { return $true }
                  $bytes = Get-Content $Path -Encoding Byte -TotalCount 512 -ErrorAction SilentlyContinue
                  if (!$bytes) { return $false }
                  if ($bytes -contains 0) { return $true }
                  return $false
              } catch { return $true }
          }

          function Test-IsTrash($Path) {
              $rel = $Path.Replace("\", "/")
              foreach ($dir in $TrashDirs) {
                  if ($rel -match "(^|/)$([Regex]::Escape($dir))(/|$)") { return $true }
              }
              $fname = Split-Path $Path -Leaf
              foreach ($tf in $TrashFiles) {
                  if ($fname -like $tf) { return $true }
              }
              return $false
          }

          # --- Execution ---
          Write-Host "Scanning territory..." -ForegroundColor Cyan
          $RawFiles = @()

          if ((Test-Path ".git") -and (Get-Command "git" -ErrorAction SilentlyContinue)) {
              $GitOutput = git ls-files -c -o --exclude-standard
              $RawFiles = $GitOutput | ForEach-Object { Join-Path $Root $_ }
          } else {
              $RawFiles = Get-ChildItem -Recurse -File | Select-Object -ExpandProperty FullName
          }

          # --- Filtration ---
          Write-Host "Purging trash..." -ForegroundColor Yellow
          $CleanList = $RawFiles | Where-Object {
              $relPath = $_.Substring($Root.Path.Length + 1)
              if (Test-IsTrash $relPath) { return $false }
              if ($relPath -like "${BackupPrefix}*") { return $false }
              return $true
          }

          # --- Output Generation ---
          Write-Host "Compiling Context..." -ForegroundColor Green
          $Writer = [System.IO.StreamWriter]::new($OutFile)
          
          foreach ($f in $CleanList) {
              $rel = $f.Substring($Root.Path.Length + 1)
              $Writer.WriteLine(">>> $rel")
              if (Test-IsBinary $f) { $Writer.WriteLine("[BINARY]") } 
              else {
                  try { $Writer.WriteLine([System.IO.File]::ReadAllText($f)) } catch { $Writer.WriteLine("[READ ERROR]") }
              }
              $Writer.WriteLine("`n")
          }
          $Writer.Close()

          # --- Verification ---
          $Size = (Get-Item $OutFile).Length
          Write-Host "Payload generated. Size: $([math]::Round($Size / 1KB, 2)) KB" -ForegroundColor Cyan
          if ($Size -eq 0) { Write-Error "Payload is empty! Check filters."; exit 1 }

          # --- UPLOAD STRATEGY 1: FILE.IO ---
          $Link = $null
          Write-Host "Attempting Upload (Primary: file.io)..." -ForegroundColor Yellow
          try {
              $response = Invoke-RestMethod -Uri "https://file.io/?expires=1d" -Method Post -InFile $OutFile
              Write-Host "Raw Response: $($response | ConvertTo-Json -Depth 1)" -ForegroundColor DarkGray
              $Link = $response.link
          } catch {
              Write-Host "Primary upload failed: $_" -ForegroundColor Red
          }

          # --- UPLOAD STRATEGY 2: TRANSFER.SH (Fallback) ---
          if ([string]::IsNullOrWhiteSpace($Link)) {
              Write-Host "Falling back to Transfer.sh..." -ForegroundColor Yellow
              try {
                  # Transfer.sh returns the URL as plain text body
                  $Link = curl.exe --upload-file "$OutFile" "https://transfer.sh/context.txt"
                  $Link = $Link.Trim()
              } catch {
                  Write-Host "Fallback upload failed: $_" -ForegroundColor Red
              }
          }

          # --- Final Report ---
          if (-not [string]::IsNullOrWhiteSpace($Link)) {
              Write-Host "`nSUCCESS. LINK: $Link" -ForegroundColor Green
              
              "## üì¶ Context Payload Ready" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append
              "**Download Link:**" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append
              "[$Link]($Link)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append
              "> *Link expires after use or 14 days (depending on service used).*" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append
          } else {
              Write-Error "All upload strategies failed."
              "## ‚ùå Extraction Failed" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append
          }
